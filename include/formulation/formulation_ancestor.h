#ifndef FORMULATION_ANCESTOR_H
#define FORMULATION_ANCESTOR_H

#include <pthread.h>

#include "../containers/mat.h"
#include "../io/xmlnode.h"

namespace LMT {

struct SparseUMFPACK;
struct SparseCholMod;


/*!
    T est le type de scalaire sur lequel travailler
 */
template<class ScalarType=double>
class FormulationAncestor {
public:
    struct LinearizedConstraint {
        struct Coeff {
            ScalarType val;
            unsigned num_in_vec;
        };
        Vec<Coeff> coeffs;
        ScalarType val;
    };

    FormulationAncestor() {
        assume_constant_matrix = false;
        default_iterative_criterium = ScalarType(0);
        non_linear_iterative_criterium = ScalarType(0);
        assume_skin_not_needed = false;
        max_non_linear_iteration = 50;
        premul_KUn_in_sollicitation = ScalarType(1);
        want_amd = false;
        want_rcm = false;
        levenberg_marquadt = ScalarType(0);
        max_diag = ScalarType(0);
        pthread_mutex_init( &mutex_assemble_matrix, NULL );
        nb_threads_assemble_matrix = 1;
    }
    virtual ~FormulationAncestor() {}

    virtual std::string get_name() const = 0; ///
    virtual void set_mesh( void *m ) = 0; ///

    virtual bool solve( ScalarType iterative_criterium=ScalarType(0), bool disp_timing=false ) = 0; ///  The all-in-one procedure -> allocate if necessary, assemble, solve, update_variables, call_after_solve
    virtual bool solve_and_get_derivatives( Vec<Vec<ScalarType> > &der, bool der_in_base_node_ordering = false ) = 0;  /// get value and derivative respective to "der_var" defined in SConsruct or in python
    virtual void allocate_matrices(bool allocate_mat=true,bool allocate_vec=true) = 0; /// alloue les matrices
    /*!
        Objectif :
            cette fonction est utilisée dans le cas d'un problème qui dépend du temps. Elle gère la correspondance d'un vecteur de solutions au problème et l'ordre temporel. Plus précisément la taille de ce vecteur est la valeur nb_der, i.e. le nombre de pas de la méthode de résolution en temps ( qui doit être au moins égal au plus grand ordre de dérivation en temps des équations aux dérivées partielles ).
            la méthode s'assure que la dernière solution calculée est à l'indice 0, la précédente à l'indice 1, etc... Et dès qu'une nouvelle solution est calculée (à la date suivante ), les vecteurs sont décalés de sorte que l'indice 0 corresponde à cette nouvelle solution.
    */
    virtual void shift(int nb=1) = 0;
    virtual void unshift(int nb=1) = 0;
    virtual unsigned update_connectivity() = 0;
    /*!
        assemble les matrices et le second membre suivant les valeurs des paramètres assemble_mat et assemble_vec.
    */
    virtual void assemble(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual bool solve_system(ScalarType iterative_criterium=ScalarType(0),bool disp_timing=false) = 0;
    virtual Vec<ScalarType> get_nodal_forces() = 0;

    virtual void assemble_clean_mat(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual void assemble_constraints(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual void assemble_sollicitations(bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual Vec<LinearizedConstraint> get_linearized_constraints() = 0;

    virtual void assemble_clean_mat     (Mat<ScalarType,Sym<>,SparseLine<> > &K, Vec<ScalarType> &F, Vec<Vec<ScalarType> > &vectors_, bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual void assemble_constraints   (Mat<ScalarType,Sym<>,SparseLine<> > &K, Vec<ScalarType> &F, Vec<Vec<ScalarType> > &vectors_, const ScalarType &M, bool assemble_mat=true,bool assemble_vec=true) = 0;
    virtual void assemble_sollicitations(Mat<ScalarType,Sym<>,SparseLine<> > &K, Vec<ScalarType> &F, Vec<Vec<ScalarType> > &vectors_, bool assemble_mat=true,bool assemble_vec=true) = 0 ;
    virtual void assemble(Mat<ScalarType,Sym<>,SparseLine<> > &K, Vec<ScalarType> &F, Vec<Vec<ScalarType> > &vectors_, bool assemble_mat=true, bool assemble_vec=true)=0;
    virtual void assemble(Mat<ScalarType,Sym<>,SparseLine<> > &A, Mat<ScalarType,Sym<>,SparseLine<> > &B, Vec<Vec<ScalarType> > &vectors_, bool assemble_mat=true)=0;
    virtual void assemble(Mat<ScalarType,Gen<>,SparseLine<> > &C, Vec<Vec<ScalarType> > &vectors_, bool assemble_mat=true)=0;

    virtual void resize() = 0;

    virtual void read_material_to_mesh(const XmlNode &) = 0;

    virtual void get_precond() = 0;
    virtual void solve_system_using_precond(ScalarType iterative_criterium) = 0;

    virtual void get_factorization_matrix() = 0;
    virtual void solve_system_using_factorization_matrix() = 0;

    virtual void call_after_solve() = 0; ///  call all after_solve in carac elem ( generated by apply_on_elements_after_solve() in formulation_...py )
    virtual void call_after_solve_2() = 0; ///  call all after_solve in carac elem ( generated by apply_on_elements_after_solve_2() in formulation_...py )
    virtual void call_after_solve_3() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )
    virtual void call_after_solve_4() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )
    virtual void call_after_solve_5() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )
    virtual void call_after_solve_6() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )
    virtual void call_after_solve_7() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_7() in formulation_...py )
    virtual void call_after_solve_8() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_8() in formulation_...py )
    virtual void call_after_solve_9() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_9() in formulation_...py )
    virtual void call_after_solve_10() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_10() in formulation_...py )
    virtual void call_after_solve_11() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_11() in formulation_...py )
    virtual void call_after_solve_12() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_12() in formulation_...py )
    virtual void call_after_solve_13() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_13() in formulation_...py )
    virtual void call_after_solve_14() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_14() in formulation_...py )
    virtual void call_after_solve_15() = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_15() in formulation_...py )

    virtual void call_after_solve(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve() in formulation_...py )
    virtual void call_after_solve_2(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_2() in formulation_...py )
    virtual void call_after_solve_3(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )
    virtual void call_after_solve_4(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_4() in formulation_...py )
    virtual void call_after_solve_5(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_5() in formulation_...py )
    virtual void call_after_solve_6(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_6() in formulation_...py )
    virtual void call_after_solve_7(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_7() in formulation_...py )
    virtual void call_after_solve_8(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_8() in formulation_...py )
    virtual void call_after_solve_9(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_9() in formulation_...py )
    virtual void call_after_solve_10(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_10() in formulation_...py )
    virtual void call_after_solve_11(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_11() in formulation_...py )
    virtual void call_after_solve_12(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_12() in formulation_...py )
    virtual void call_after_solve_13(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_13() in formulation_...py )
    virtual void call_after_solve_14(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_14() in formulation_...py )
    virtual void call_after_solve_15(unsigned nb_thread) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_15() in formulation_...py )

    virtual void call_after_solve(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_2(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_3(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_4(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_5(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_6(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_7(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_8(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_9(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_10(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_11(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_12(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_13(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_14(Vec<Vec<ScalarType> > &vectors) = 0 ;
    virtual void call_after_solve_15(Vec<Vec<ScalarType> > &vectors) = 0 ;

    virtual void call_after_solve(    Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_2(  Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_3(  Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_4(  Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_5(  Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_6(  Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_7(  Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_8(  Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_9(  Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_10( Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_11( Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_12( Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_13( Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_14( Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;
    virtual void call_after_solve_15( Vec<Vec<ScalarType> > &vectors, unsigned nb_thread ) = 0 ;

    virtual void set_vectors_assembly(Vec<Vec<ScalarType> > &vec) = 0;
    virtual void set_indice_noda(Vec<unsigned> &vec) = 0;
    virtual void set_indice_elem(Vec<unsigned>* vec) = 0;
    virtual void set_indice_glob(unsigned &val) = 0 ;
    virtual void set_f_nodal(Vec<ScalarType>* vec) = 0 ;

    virtual unsigned get_nb_vectors() = 0;

    virtual void call_after_solve(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve() in formulation_...py )
    virtual void call_after_solve_2(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_2() in formulation_...py )
    virtual void call_after_solve_3(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )
    virtual void call_after_solve_4(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_2() in formulation_...py )
    virtual void call_after_solve_5(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )
    virtual void call_after_solve_6(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )
    virtual void call_after_solve_7(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_3() in formulation_...py )
    virtual void call_after_solve_8(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_8() in formulation_...py )
    virtual void call_after_solve_9(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_9() in formulation_...py )
    virtual void call_after_solve_10(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_10() in formulation_...py )
    virtual void call_after_solve_11(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_11() in formulation_...py )
    virtual void call_after_solve_12(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_12() in formulation_...py )
    virtual void call_after_solve_13(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_13() in formulation_...py )
    virtual void call_after_solve_14(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_14() in formulation_...py )
    virtual void call_after_solve_15(const Vec<void *> &elem_list) = 0; /// call all after_solve in carac elem ( generated by apply_on_elements_after_solve_15() in formulation_...py )

    virtual unsigned localOP_local_update()= 0;
    virtual void localOP_update_variables() = 0;    /// update variable at end of the time step from the c++ code.
    virtual void update_variables() = 0; /// update variable at end of the time step
    virtual void update_variables(Vec<Vec<ScalarType> > &vectors_) = 0; /// update variable at end of the time step
    virtual void update_variables(ScalarType partial_ts) = 0; ///  update variable at time t_n + partial_ts
    virtual void get_initial_conditions() = 0; /// fill vectors[x] using dern_unknown
    virtual void get_initial_conditions(Vec<Vec<ScalarType> > &vectors_) = 0; /// fill vectors[x] using dern_unknown

    virtual void Get_Nb_UnknownByElement( unsigned* nb_elem_of_type, unsigned &size,  unsigned* nb_unknowns_for_type) = 0 ;

    virtual void     set_indice_noda(unsigned num_node, unsigned index) const = 0;
    virtual unsigned get_indice_noda(unsigned num_node) const = 0;
    virtual unsigned num_in_vec_unknown(const std::string &name) const = 0;

    /**
     * add a constraint which will be added to system during assembly
     * @param txt constraint in analytic form. Example : "node[0].temperature + time**2 - 10"
     * @param penalty_value constraint will be * by max(abs(diag))*penalty_value
     * @return number of constraint (usefull in order to remove it...)
     */
    virtual unsigned add_constraint(const std::string &txt,const ScalarType &penalty_value) = 0;
    virtual void set_initial_time_step( ScalarType ts ) = 0; ///
    virtual ScalarType get_next_time_step() const = 0; ///
    virtual ScalarType get_time() const = 0; ///
    virtual void set_time( ScalarType ts ) = 0; /// Attention, pilotage a faire soi-meme si utilisation de cette fonction....
    virtual void clean_mats() = 0; /// 0 in all matrices
    virtual void free_matrices() = 0;///free all matrices
    virtual unsigned nb_constraints() const = 0;
    virtual void erase_constraints() = 0;
    virtual void erase_constraints_from(unsigned number) = 0;

    virtual unsigned get_nb_nodal_unknowns() const = 0;
    virtual unsigned get_nb_global_unknowns() const = 0;
    virtual unsigned get_nb_elem_unknowns() const = 0;

    /*!
        Objectif :
            cette méthode ajoute au vecteur <strong> res </strong>, la contribution au résidu de l'élément <strong> *elem </strong> .

        Paramètres :
            * <strong> res </strong> le vecteur contenant le résidu ( sa taille doit être égale au nombre de degrés de liberté du problème),
            * <strong> elem </strong> pointeur sur l'élément dont on veut obtenir la contribution.
    */
    virtual void add_elem_contribution_to_residual( Vec<ScalarType> &res, const void *elem ) const = 0;
    virtual Vec<ScalarType> get_residual() const = 0;

    #ifdef WITH_UMFPACK
    virtual void get_mat( Mat<ScalarType,Gen<>,SparseUMFPACK> *&mat ) = 0; ///
    #endif
    virtual void get_mat( Mat<ScalarType,Gen<>,SparseLU> *&mat ) = 0; ///
    #ifdef WITH_CHOLMOD
    virtual void get_mat( Mat<ScalarType,Sym<>,SparseCholMod> *&mat ) = 0; ///
    #endif
    virtual void get_mat( Mat<ScalarType,Sym<>,SparseLine<> > *&mat ) = 0; ///

    virtual void display_mat( std::ostream &os ) const = 0; ///

    virtual void get_der_var_on_mesh( unsigned num_der_var ) = 0;

    virtual Vec<ScalarType> &get_sollicitation() = 0; ///
    virtual Vec<ScalarType> &get_result(unsigned num=0) = 0; ///

    virtual unsigned nb_constrained_nodes() const = 0;
    virtual unsigned nb_constrained_nodes_in_dim( unsigned dim ) const = 0;
    virtual Vec<bool> constrained_nodes() const = 0; /// renvoie un vecteur de la taille égal au nombre de noeuds et qui vaut vrai si le noeud est contraint.
    virtual Vec<bool> constrained_nodes_in_dim( unsigned dim ) const = 0; /// renvoie un vecteur de la taille égal au nombre de noeuds et qui vaut vrai si le noeud est contraint dans la direction dim.

    bool assume_constant_matrix; ///
    ScalarType default_iterative_criterium; /// iterative_criterium for conjugate gradient, GMRES, ... based on norm_inf( delta solution )
    ScalarType non_linear_iterative_criterium; /// iterative_criterium for newton-raphson iterations, ... based on norm_inf( delta solution )
    Vec<ScalarType> non_linear_iterative_criterium_vec; /// iterative_criterium for newton-raphson iterations, ... based on norm_inf( delta solution )
    // unsigned order_integration_when_integration_totale;
    bool assume_skin_not_needed;
    unsigned max_non_linear_iteration;
    ScalarType premul_KUn_in_sollicitation;
    bool want_amd, want_rcm;
    ScalarType levenberg_marquadt; /// K += levenberg_marquadt * max( abs( K ) ) * Id; 0 by default
    ScalarType max_diag;
    Vec<unsigned> id;/// indice pour les variables
    unsigned  nb_threads_assemble_matrix;
    mutable pthread_mutex_t mutex_assemble_matrix;

    virtual void *get_mesh() = 0; /// recupere le maillage associee a une formulation (mais pas avec le bon type)
};

}

#endif // FORMULATION_ANCESTOR_H
